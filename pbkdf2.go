package crypt

import "C"
import (
	"crypto/rand"
	"fmt"
	"io"

	"github.com/go-crypt/x/pbkdf2"
)

const (
	hashPBKDF2DefaultIterationsSHA1   = 720000
	hashPBKDF2DefaultIterationsSHA256 = 310000
	hashPBKDF2DefaultIterationsSHA512 = 120000
	hashPBKDF2DefaultDigest           = DigestSHA256
)

type PBKDF2Hash struct {
	digest     string
	iterations int

	keySize, saltSize uint32

	salt string
}

// WithDigest adjusts the digest of the PBKDF2 algorithm. Valid values are sha1, sha256, sha512. Default is
// sha512.
func (b *PBKDF2Hash) WithDigest(digest string) *PBKDF2Hash {
	switch digest {
	case DigestSHA1, DigestSHA224, DigestSHA256, DigestSHA384, DigestSHA512:
		b.digest = digest
	}

	return b
}

// WithKeySize adjusts the key size of the resulting PBKDF2 hash. Default is 32.
func (b *PBKDF2Hash) WithKeySize(size uint32) *PBKDF2Hash {
	b.keySize = size

	return b
}

// WithSaltSize adjusts the salt size of the resulting PBKDF2 hash. Default is 16.
func (b *PBKDF2Hash) WithSaltSize(size uint32) *PBKDF2Hash {
	b.saltSize = size

	return b
}

// WithSalt sets the salt of the resulting PBKDF2 hash. Default is generated by crypto/rand.
func (b *PBKDF2Hash) WithSalt(salt string) *PBKDF2Hash {
	b.salt = salt

	return b
}

// WithIterations sets the iterations parameter of the resulting PBKDF2 hash. Default is 29000.
func (b *PBKDF2Hash) WithIterations(iterations int) *PBKDF2Hash {
	b.iterations = iterations

	return b
}

// Build checks the options are all configured correctly, setting defaults as necessary, calculates the password hash,
// and returns the Argon2id hash.
func (b PBKDF2Hash) Build(password string) (h *PBKDF2Digest, err error) {
	h = &PBKDF2Digest{
		iterations: b.iterations,
		k:          int(b.keySize),
	}

	h.variant = NewPBKDF2Variant(b.digest)

	if h.iterations <= 0 {
		switch b.digest {
		case DigestSHA1, DigestSHA224:
			h.iterations = hashPBKDF2DefaultIterationsSHA1
		case DigestSHA256, DigestSHA384:
			h.iterations = hashPBKDF2DefaultIterationsSHA256
		case DigestSHA512:
			h.iterations = hashPBKDF2DefaultIterationsSHA512
		}
	}

	if h.k == 0 {
		h.k = defaultKeySize
	}

	if b.salt != "" {
		if h.salt, err = b64rs.DecodeString(b.salt); err != nil {
			return nil, fmt.Errorf("error decoding Password salt from base64: %w", err)
		}
	} else {
		var (
			size = b.saltSize
		)

		if size <= 0 {
			size = defaultSaltSize
		}

		h.salt = make([]byte, size)

		if _, err = io.ReadFull(rand.Reader, h.salt); err != nil {
			return nil, fmt.Errorf("error reading random bytes for the salt: %w", err)
		}
	}

	h.key = pbkdf2.Key([]byte(password), h.salt, h.iterations, h.k, h.variant.HashFunc())

	return h, nil
}
